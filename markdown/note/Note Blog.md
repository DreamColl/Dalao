# Note Blog

#### [尾调用优化-阮一峰](http://www.ruanyifeng.com/blog/2015/04/tail-call.html) | [什么是尾递归-知乎](https://www.zhihu.com/question/20761771)

```
常规的递归是这样 函数没执行完去调用函数自身 会新建一个调用堆栈（优先入栈）
尾递归优化是什么呢 如果你在最后一行 return 函数自身的运行时
会优先传值,之前的调用堆栈就销毁了
防止调用堆栈的堆积消耗大量内存
因为优先入栈的逻辑 在最后一个函数出栈之前，之前所有的函数都必须在调用堆栈里,得按顺序一个一个进一个一个出
```
#### 封装的原则

```
封装的原则：高内聚，低耦合
面对对象的原则：单一职责，开放封闭，里氏替换，接口分离，依赖倒置
扩展的原则：迪米特法则，好莱坞法则，优先使用组合原则
```
#### [JS代码实现瀑布流](https://segmentfault.com/a/1190000012621936) | [Git瀑布流思路及简介](https://github.com/jatfret/blog/issues/2)

```
核心：下一个元素放哪？
1. 简单办法
上好几个ul，最小的塞进去
2. 定宽不定高的原理
相对父元素进行绝对定位，先确定列数，将第一列图片排布，取第一列图片的高度存于数组内。然后将新图片放在最小列，重新计算最小列。

```

